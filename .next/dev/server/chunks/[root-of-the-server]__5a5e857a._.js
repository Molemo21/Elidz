module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[project]/lib/supabase/server.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$1$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$84$2e$0$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@supabase+ssr@0.1.0_@supabase+supabase-js@2.84.0/node_modules/@supabase/ssr/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.3_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
async function createClient() {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$1$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$84$2e$0$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createServerClient"])(("TURBOPACK compile-time value", "https://nxdjdkoamvertmzgslyq.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im54ZGpka29hbXZlcnRtemdzbHlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5OTUwMTgsImV4cCI6MjA3OTU3MTAxOH0.2qdDKkJUEPI-bsA15NuEe4vz9XjsFQuZmtYeF_UbOzI"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>cookieStore.set(name, value, options));
                } catch  {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
}
}),
"[project]/lib/db/queries.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Reusable query helpers with consistent error handling
// These provide a standardized way to interact with the database
__turbopack_context__.s([
    "applicationQueries",
    ()=>applicationQueries,
    "matchQueries",
    ()=>matchQueries,
    "opportunityQueries",
    ()=>opportunityQueries,
    "userProfileQueries",
    ()=>userProfileQueries,
    "userQueries",
    ()=>userQueries
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase/server.ts [app-route] (ecmascript)");
;
/**
 * Generic error handler for Supabase errors
 * Maps common error codes to user-friendly messages
 */ function handleSupabaseError(error) {
    // Unique constraint violation (duplicate key)
    if (error?.code === '23505') {
        return {
            success: false,
            error: 'Record already exists',
            code: 'DUPLICATE'
        };
    }
    // Foreign key violation
    if (error?.code === '23503') {
        return {
            success: false,
            error: 'Referenced record does not exist',
            code: 'FOREIGN_KEY'
        };
    }
    // Not found
    if (error?.code === 'PGRST116') {
        return {
            success: false,
            error: 'Record not found',
            code: 'NOT_FOUND'
        };
    }
    // Permission denied (RLS)
    if (error?.code === '42501' || error?.message?.includes('permission denied')) {
        return {
            success: false,
            error: 'Permission denied',
            code: 'PERMISSION_DENIED'
        };
    }
    // Generic error
    return {
        success: false,
        error: error?.message || 'Database operation failed',
        code: error?.code
    };
}
const userProfileQueries = {
    /**
   * Get user profile by user ID
   */ async getByUserId (userId) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('user_profiles').select('*').eq('user_id', userId).maybeSingle();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'Profile not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Upsert user profile (create or update)
   */ async upsert (userId, profile) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('user_profiles').upsert({
                ...profile,
                user_id: userId
            }, {
                onConflict: 'user_id'
            }).select().single();
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Update user profile (partial update)
   */ async update (userId, updates) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('user_profiles').update(updates).eq('user_id', userId).select().single();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'Profile not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Check if profile is complete (has all required onboarding data)
   */ async isComplete (userId) {
        try {
            const result = await this.getByUserId(userId);
            if (!result.success || !result.data) return false;
            const profile = result.data;
            // Check required fields
            const required = [
                profile.company_name,
                profile.registration_number,
                profile.industry,
                profile.business_description,
                profile.location,
                profile.annual_revenue,
                profile.employees_count,
                profile.years_in_business,
                profile.funding_requirements
            ];
            if (required.some((field)=>field === null || field === undefined || field === '')) {
                return false;
            }
            // Validate funding_requirements structure
            const fundingReqs = profile.funding_requirements;
            if (!fundingReqs?.amount_needed || !fundingReqs?.funding_purpose) {
                return false;
            }
            return true;
        } catch  {
            return false;
        }
    }
};
const userQueries = {
    /**
   * Get all users (admin only - caller must verify admin status)
   */ async getAll () {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('users').select('*').order('created_at', {
                ascending: false
            });
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data || []
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Get user by ID
   */ async getById (userId) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('users').select('*').eq('id', userId).maybeSingle();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'User not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Get user by email
   */ async getByEmail (email) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('users').select('*').eq('email', email).maybeSingle();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'User not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Update user approval status
   */ async updateApproval (userId, approved) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('users').update({
                approved
            }).eq('id', userId).select().single();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'User not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Update user last login timestamp
   */ async updateLastLogin (userId) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('users').update({
                last_login: new Date().toISOString()
            }).eq('id', userId).select().single();
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    }
};
const opportunityQueries = {
    /**
   * Get all opportunities
   */ async getAll () {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('funding_opportunities').select('*').order('created_at', {
                ascending: false
            });
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data || []
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Get opportunity by ID
   */ async getById (opportunityId) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('funding_opportunities').select('*').eq('id', opportunityId).maybeSingle();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'Opportunity not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Get opportunities by industry
   */ async getByIndustry (industry) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('funding_opportunities').select('*').contains('industry_focus', [
                industry
            ]).order('created_at', {
                ascending: false
            });
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data || []
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Get active opportunities (deadline in future)
   */ async getActive () {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const now = new Date().toISOString();
            const { data, error } = await supabase.from('funding_opportunities').select('*').gt('deadline', now).order('deadline', {
                ascending: true
            });
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data || []
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    }
};
const matchQueries = {
    /**
   * Get matches for user
   */ async getByUserId (userId) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('matches').select('*').eq('user_id', userId).order('match_score', {
                ascending: false
            });
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data || []
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Update match status
   */ async updateStatus (matchId, status) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const updateData = {
                status
            };
            if (status === 'viewed') {
                updateData.viewed_at = new Date().toISOString();
            }
            const { data, error } = await supabase.from('matches').update(updateData).eq('id', matchId).select().single();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'Match not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    }
};
const applicationQueries = {
    /**
   * Get applications for user
   */ async getByUserId (userId) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('applications').select('*').eq('user_id', userId).order('created_at', {
                ascending: false
            });
            if (error) return handleSupabaseError(error);
            return {
                success: true,
                data: data || []
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Get application by ID
   */ async getById (applicationId) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const { data, error } = await supabase.from('applications').select('*').eq('id', applicationId).maybeSingle();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'Application not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    },
    /**
   * Update application status
   */ async updateStatus (applicationId, status) {
        try {
            const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
            const updateData = {
                status
            };
            if (status === 'submitted') {
                updateData.submitted_at = new Date().toISOString();
            } else if (status === 'approved' || status === 'rejected') {
                updateData.reviewed_at = new Date().toISOString();
            }
            const { data, error } = await supabase.from('applications').update(updateData).eq('id', applicationId).select().single();
            if (error) return handleSupabaseError(error);
            if (!data) return {
                success: false,
                error: 'Application not found',
                code: 'NOT_FOUND'
            };
            return {
                success: true,
                data
            };
        } catch (error) {
            return handleSupabaseError(error);
        }
    }
};
}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}),
"[project]/lib/prisma.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Prisma Client singleton
// Use this instead of creating new PrismaClient instances
__turbopack_context__.s([
    "prisma",
    ()=>prisma
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
const globalForPrisma = globalThis;
// Verify DATABASE_URL is set
if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL environment variable is not set. Please check your .env.local file and ensure it contains DATABASE_URL.');
}
const prisma = globalForPrisma.prisma ?? new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]({
    log: ("TURBOPACK compile-time truthy", 1) ? [
        'query',
        'error',
        'warn'
    ] : "TURBOPACK unreachable"
});
if ("TURBOPACK compile-time truthy", 1) globalForPrisma.prisma = prisma;
}),
"[project]/lib/db/queries-prisma.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Prisma Query Helpers - Production Ready
// Migrated from Supabase queries with best practices
// 
// Key improvements:
// - Full type safety with Prisma generated types
// - Consistent error handling
// - Better performance with optimized queries
// - Clearer, more maintainable code
__turbopack_context__.s([
    "applicationQueries",
    ()=>applicationQueries,
    "matchQueries",
    ()=>matchQueries,
    "opportunityQueries",
    ()=>opportunityQueries,
    "userProfileQueries",
    ()=>userProfileQueries,
    "userQueries",
    ()=>userQueries
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/prisma.ts [app-route] (ecmascript)");
;
/**
 * Prisma error handler - maps Prisma errors to consistent format
 */ function handlePrismaError(error) {
    // Record not found (P2025)
    if (error?.code === 'P2025') {
        return {
            success: false,
            error: 'Record not found',
            code: 'NOT_FOUND'
        };
    }
    // Unique constraint violation (P2002)
    if (error?.code === 'P2002') {
        const field = error.meta?.target?.[0] || 'field';
        return {
            success: false,
            error: `Record with this ${field} already exists`,
            code: 'DUPLICATE'
        };
    }
    // Foreign key constraint violation (P2003)
    if (error?.code === 'P2003') {
        return {
            success: false,
            error: 'Referenced record does not exist',
            code: 'FOREIGN_KEY'
        };
    }
    // Generic error
    return {
        success: false,
        error: error?.message || 'Database operation failed',
        code: error?.code
    };
}
const userProfileQueries = {
    /**
   * Get user profile by user ID
   */ async getByUserId (userId) {
        try {
            const profile = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].userProfile.findUnique({
                where: {
                    userId
                }
            });
            if (!profile) {
                return {
                    success: false,
                    error: 'Profile not found',
                    code: 'NOT_FOUND'
                };
            }
            return {
                success: true,
                data: profile
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Upsert user profile (create or update)
   */ async upsert (userId, profile// Accept any for flexibility, will be validated by caller
    ) {
        try {
            const result = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].userProfile.upsert({
                where: {
                    userId
                },
                update: profile,
                create: {
                    userId,
                    ...profile
                }
            });
            return {
                success: true,
                data: result
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Update user profile (partial update)
   */ async update (userId, updates) {
        try {
            const profile = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].userProfile.update({
                where: {
                    userId
                },
                data: updates
            });
            return {
                success: true,
                data: profile
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Check if profile is complete (has all required onboarding data)
   */ async isComplete (userId) {
        try {
            const result = await this.getByUserId(userId);
            if (!result.success || !result.data) return false;
            const profile = result.data;
            // Check required fields
            const required = [
                profile.companyName,
                profile.registrationNumber,
                profile.industry,
                profile.businessDescription,
                profile.location,
                profile.annualRevenue,
                profile.employeesCount,
                profile.yearsInBusiness,
                profile.fundingRequirements
            ];
            if (required.some((field)=>field === null || field === undefined || field === '')) {
                return false;
            }
            // Validate funding_requirements structure
            const fundingReqs = profile.fundingRequirements;
            if (!fundingReqs?.amount_needed || !fundingReqs?.funding_purpose) {
                return false;
            }
            return true;
        } catch  {
            return false;
        }
    }
};
const userQueries = {
    /**
   * Get all users (admin only - caller must verify admin status)
   */ async getAll () {
        try {
            const users = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findMany({
                orderBy: {
                    createdAt: 'desc'
                }
            });
            return {
                success: true,
                data: users
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Get user by ID
   */ async getById (userId) {
        try {
            const user = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findUnique({
                where: {
                    id: userId
                }
            });
            if (!user) {
                return {
                    success: false,
                    error: 'User not found',
                    code: 'NOT_FOUND'
                };
            }
            return {
                success: true,
                data: user
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Get user by email
   */ async getByEmail (email) {
        try {
            const user = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findUnique({
                where: {
                    email
                }
            });
            if (!user) {
                return {
                    success: false,
                    error: 'User not found',
                    code: 'NOT_FOUND'
                };
            }
            return {
                success: true,
                data: user
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Update user approval status
   */ async updateApproval (userId, approved) {
        try {
            const user = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.update({
                where: {
                    id: userId
                },
                data: {
                    approved
                }
            });
            return {
                success: true,
                data: user
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Update user last login timestamp
   */ async updateLastLogin (userId) {
        try {
            const user = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.update({
                where: {
                    id: userId
                },
                data: {
                    lastLogin: new Date()
                }
            });
            return {
                success: true,
                data: user
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    }
};
const opportunityQueries = {
    /**
   * Get all opportunities
   */ async getAll () {
        try {
            const opportunities = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].fundingOpportunity.findMany({
                orderBy: {
                    createdAt: 'desc'
                }
            });
            return {
                success: true,
                data: opportunities
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Get opportunity by ID
   */ async getById (opportunityId) {
        try {
            const opportunity = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].fundingOpportunity.findUnique({
                where: {
                    id: opportunityId
                }
            });
            if (!opportunity) {
                return {
                    success: false,
                    error: 'Opportunity not found',
                    code: 'NOT_FOUND'
                };
            }
            return {
                success: true,
                data: opportunity
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Get opportunities by industry
   */ async getByIndustry (industry) {
        try {
            const opportunities = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].fundingOpportunity.findMany({
                where: {
                    industryFocus: {
                        has: industry
                    }
                },
                orderBy: {
                    createdAt: 'desc'
                }
            });
            return {
                success: true,
                data: opportunities
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Get active opportunities (deadline in future)
   */ async getActive () {
        try {
            const now = new Date();
            const opportunities = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].fundingOpportunity.findMany({
                where: {
                    deadline: {
                        gt: now
                    }
                },
                orderBy: {
                    deadline: 'asc'
                }
            });
            return {
                success: true,
                data: opportunities
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    }
};
const matchQueries = {
    /**
   * Get matches for user
   */ async getByUserId (userId) {
        try {
            const matches = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].match.findMany({
                where: {
                    userId
                },
                orderBy: {
                    matchScore: 'desc'
                }
            });
            return {
                success: true,
                data: matches
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Update match status
   */ async updateStatus (matchId, status// 'new' | 'viewed' | 'interested' | 'applied'
    ) {
        try {
            const updateData = {
                status
            };
            // Set viewed_at when status becomes 'viewed'
            if (status === 'viewed') {
                updateData.viewedAt = new Date();
            }
            const match = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].match.update({
                where: {
                    id: matchId
                },
                data: updateData
            });
            return {
                success: true,
                data: match
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    }
};
const applicationQueries = {
    /**
   * Get applications for user
   */ async getByUserId (userId) {
        try {
            const applications = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].application.findMany({
                where: {
                    userId
                },
                orderBy: {
                    createdAt: 'desc'
                }
            });
            return {
                success: true,
                data: applications
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Get application by ID
   */ async getById (applicationId) {
        try {
            const application = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].application.findUnique({
                where: {
                    id: applicationId
                }
            });
            if (!application) {
                return {
                    success: false,
                    error: 'Application not found',
                    code: 'NOT_FOUND'
                };
            }
            return {
                success: true,
                data: application
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    },
    /**
   * Update application status
   */ async updateStatus (applicationId, status// 'draft' | 'in_review' | 'submitted' | 'approved' | 'rejected'
    ) {
        try {
            const updateData = {
                status
            };
            if (status === 'submitted') {
                updateData.submittedAt = new Date();
            } else if (status === 'approved' || status === 'rejected') {
                updateData.reviewedAt = new Date();
            }
            const application = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].application.update({
                where: {
                    id: applicationId
                },
                data: updateData
            });
            return {
                success: true,
                data: application
            };
        } catch (error) {
            return handlePrismaError(error);
        }
    }
};
}),
"[project]/lib/db/test-queries-comparison.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Query Comparison Test
// This file tests Supabase queries vs Prisma queries side-by-side
// Run with: node -r ts-node/register lib/db/test-queries-comparison.ts
// Or import and use in a test page
__turbopack_context__.s([
    "printTestSummary",
    ()=>printTestSummary,
    "runQueryComparisonTests",
    ()=>runQueryComparisonTests
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db/queries.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db/queries-prisma.ts [app-route] (ecmascript)");
;
;
;
;
;
;
/**
 * Compare two results and return differences
 */ function compareResults(supabase, prisma) {
    const differences = [];
    // Check if both succeeded
    if (supabase.success !== prisma.success) {
        differences.push(`Success mismatch: Supabase=${supabase.success}, Prisma=${prisma.success}`);
        return {
            match: false,
            differences
        };
    }
    if (!supabase.success || !prisma.success) {
        // Both failed - check error messages
        if (supabase.error !== prisma.error) {
            differences.push(`Error mismatch: Supabase="${supabase.error}", Prisma="${prisma.error}"`);
            return {
                match: false,
                differences
            };
        }
        return {
            match: true
        } // Both failed with same error - considered a match
        ;
    }
    // Both succeeded - compare data
    const supabaseData = supabase.data;
    const prismaData = prisma.data;
    if (Array.isArray(supabaseData) && Array.isArray(prismaData)) {
        if (supabaseData.length !== prismaData.length) {
            differences.push(`Array length mismatch: Supabase=${supabaseData.length}, Prisma=${prismaData.length}`);
            return {
                match: false,
                differences
            };
        }
        // Compare each item (simplified - just check IDs)
        supabaseData.forEach((item, index)=>{
            if (item.id !== prismaData[index]?.id) {
                differences.push(`Item ${index} ID mismatch: Supabase=${item.id}, Prisma=${prismaData[index]?.id}`);
            }
        });
    } else if (supabaseData && prismaData) {
        // Compare objects
        if (supabaseData.id !== prismaData.id) {
            differences.push(`ID mismatch: Supabase=${supabaseData.id}, Prisma=${prismaData.id}`);
        }
    } else if (!supabaseData && !prismaData) {
        // Both null - match
        return {
            match: true
        };
    } else {
        differences.push(`Data presence mismatch: Supabase has data=${!!supabaseData}, Prisma has data=${!!prismaData}`);
        return {
            match: false,
            differences
        };
    }
    return {
        match: differences.length === 0,
        differences: differences.length > 0 ? differences : undefined
    };
}
async function runQueryComparisonTests() {
    const results = [];
    console.log('ðŸ§ª Starting Query Comparison Tests...\n');
    // Test 1: Get All Users
    try {
        console.log('Test 1: Getting all users...');
        const supabaseResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getAll();
        const prismaResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getAll();
        const comparison = compareResults(supabaseResult, prismaResult);
        results.push({
            testName: 'Get All Users',
            supabaseResult,
            prismaResult,
            ...comparison
        });
        console.log(`  âœ… Supabase: ${supabaseResult.success ? 'Success' : 'Failed'}`);
        console.log(`  âœ… Prisma: ${prismaResult.success ? 'Success' : 'Failed'}`);
        console.log(`  ${comparison.match ? 'âœ…' : 'âŒ'} Results match: ${comparison.match}\n`);
    } catch (error) {
        console.error('  âŒ Test 1 failed:', error.message);
        results.push({
            testName: 'Get All Users',
            supabaseResult: {
                success: false,
                error: error.message
            },
            prismaResult: {
                success: false,
                error: error.message
            },
            match: false,
            differences: [
                error.message
            ]
        });
    }
    // Test 2: Get User by ID (using first user from Test 1)
    try {
        const allUsersResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getAll();
        if (allUsersResult.success && allUsersResult.data && allUsersResult.data.length > 0) {
            const testUserId = allUsersResult.data[0].id;
            console.log(`Test 2: Getting user by ID (${testUserId})...`);
            const supabaseResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getById(testUserId);
            const prismaResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getById(testUserId);
            const comparison = compareResults(supabaseResult, prismaResult);
            results.push({
                testName: 'Get User by ID',
                supabaseResult,
                prismaResult,
                ...comparison
            });
            console.log(`  âœ… Supabase: ${supabaseResult.success ? 'Success' : 'Failed'}`);
            console.log(`  âœ… Prisma: ${prismaResult.success ? 'Success' : 'Failed'}`);
            console.log(`  ${comparison.match ? 'âœ…' : 'âŒ'} Results match: ${comparison.match}\n`);
        } else {
            console.log('  âš ï¸  Skipped: No users found for testing\n');
        }
    } catch (error) {
        console.error('  âŒ Test 2 failed:', error.message);
    }
    // Test 3: Get User by Email
    try {
        const allUsersResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getAll();
        if (allUsersResult.success && allUsersResult.data && allUsersResult.data.length > 0) {
            const testEmail = allUsersResult.data[0].email;
            console.log(`Test 3: Getting user by email (${testEmail})...`);
            const supabaseResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getByEmail(testEmail);
            const prismaResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getByEmail(testEmail);
            const comparison = compareResults(supabaseResult, prismaResult);
            results.push({
                testName: 'Get User by Email',
                supabaseResult,
                prismaResult,
                ...comparison
            });
            console.log(`  âœ… Supabase: ${supabaseResult.success ? 'Success' : 'Failed'}`);
            console.log(`  âœ… Prisma: ${prismaResult.success ? 'Success' : 'Failed'}`);
            console.log(`  ${comparison.match ? 'âœ…' : 'âŒ'} Results match: ${comparison.match}\n`);
        } else {
            console.log('  âš ï¸  Skipped: No users found for testing\n');
        }
    } catch (error) {
        console.error('  âŒ Test 3 failed:', error.message);
    }
    // Test 4: Get All Opportunities
    try {
        console.log('Test 4: Getting all opportunities...');
        const supabaseResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["opportunityQueries"].getAll();
        const prismaResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["opportunityQueries"].getAll();
        const comparison = compareResults(supabaseResult, prismaResult);
        results.push({
            testName: 'Get All Opportunities',
            supabaseResult,
            prismaResult,
            ...comparison
        });
        console.log(`  âœ… Supabase: ${supabaseResult.success ? 'Success' : 'Failed'}`);
        console.log(`  âœ… Prisma: ${prismaResult.success ? 'Success' : 'Failed'}`);
        console.log(`  ${comparison.match ? 'âœ…' : 'âŒ'} Results match: ${comparison.match}\n`);
    } catch (error) {
        console.error('  âŒ Test 4 failed:', error.message);
    }
    // Test 5: Get Active Opportunities
    try {
        console.log('Test 5: Getting active opportunities...');
        const supabaseResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["opportunityQueries"].getActive();
        const prismaResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["opportunityQueries"].getActive();
        const comparison = compareResults(supabaseResult, prismaResult);
        results.push({
            testName: 'Get Active Opportunities',
            supabaseResult,
            prismaResult,
            ...comparison
        });
        console.log(`  âœ… Supabase: ${supabaseResult.success ? 'Success' : 'Failed'}`);
        console.log(`  âœ… Prisma: ${prismaResult.success ? 'Success' : 'Failed'}`);
        console.log(`  ${comparison.match ? 'âœ…' : 'âŒ'} Results match: ${comparison.match}\n`);
    } catch (error) {
        console.error('  âŒ Test 5 failed:', error.message);
    }
    // Test 6: Get User Profile (if user exists)
    try {
        const allUsersResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userQueries"].getAll();
        if (allUsersResult.success && allUsersResult.data && allUsersResult.data.length > 0) {
            const testUserId = allUsersResult.data[0].id;
            console.log(`Test 6: Getting user profile for user ${testUserId}...`);
            const supabaseResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userProfileQueries"].getByUserId(testUserId);
            const prismaResult = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$queries$2d$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["userProfileQueries"].getByUserId(testUserId);
            const comparison = compareResults(supabaseResult, prismaResult);
            results.push({
                testName: 'Get User Profile',
                supabaseResult,
                prismaResult,
                ...comparison
            });
            console.log(`  âœ… Supabase: ${supabaseResult.success ? 'Success' : 'Failed'}`);
            console.log(`  âœ… Prisma: ${prismaResult.success ? 'Success' : 'Failed'}`);
            console.log(`  ${comparison.match ? 'âœ…' : 'âŒ'} Results match: ${comparison.match}\n`);
        } else {
            console.log('  âš ï¸  Skipped: No users found for testing\n');
        }
    } catch (error) {
        console.error('  âŒ Test 6 failed:', error.message);
    }
    return results;
}
function printTestSummary(results) {
    console.log('\n' + '='.repeat(60));
    console.log('ðŸ“Š TEST SUMMARY');
    console.log('='.repeat(60) + '\n');
    const passed = results.filter((r)=>r.match).length;
    const failed = results.filter((r)=>!r.match).length;
    const total = results.length;
    console.log(`Total Tests: ${total}`);
    console.log(`âœ… Passed: ${passed}`);
    console.log(`âŒ Failed: ${failed}`);
    console.log(`Success Rate: ${(passed / total * 100).toFixed(1)}%\n`);
    if (failed > 0) {
        console.log('âŒ FAILED TESTS:');
        console.log('-'.repeat(60));
        results.filter((r)=>!r.match).forEach((result)=>{
            console.log(`\n${result.testName}:`);
            if (result.differences) {
                result.differences.forEach((diff)=>console.log(`  - ${diff}`));
            }
        });
        console.log('\n');
    }
    console.log('='.repeat(60) + '\n');
}
}),
"[project]/app/api/test/query-comparison/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// API Route to test query comparison
// GET /api/test/query-comparison
// This runs Supabase vs Prisma query comparisons
__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.3_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$test$2d$queries$2d$comparison$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db/test-queries-comparison.ts [app-route] (ecmascript)");
;
;
async function GET() {
    try {
        console.log('Starting query comparison tests...');
        const results = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$test$2d$queries$2d$comparison$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["runQueryComparisonTests"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2f$test$2d$queries$2d$comparison$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["printTestSummary"])(results);
        const passed = results.filter((r)=>r.match).length;
        const failed = results.filter((r)=>!r.match).length;
        const total = results.length;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            summary: {
                total,
                passed,
                failed,
                successRate: (passed / total * 100).toFixed(1) + '%'
            },
            results: results.map((r)=>({
                    testName: r.testName,
                    match: r.match,
                    differences: r.differences,
                    supabaseSuccess: r.supabaseResult.success,
                    prismaSuccess: r.prismaResult.success,
                    supabaseError: r.supabaseResult.error,
                    prismaError: r.prismaResult.error
                }))
        });
    } catch (error) {
        console.error('Query comparison test failed:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: error.message || 'Failed to run comparison tests'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__5a5e857a._.js.map