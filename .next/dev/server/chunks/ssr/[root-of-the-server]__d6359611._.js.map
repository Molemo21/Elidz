{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/prisma.ts"],"sourcesContent":["// Prisma Client singleton\r\n// Use this instead of creating new PrismaClient instances\r\n\r\nimport { PrismaClient } from '@prisma/client'\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined\r\n}\r\n\r\n// Verify DATABASE_URL is set\r\nif (!process.env.DATABASE_URL) {\r\n  throw new Error(\r\n    'DATABASE_URL environment variable is not set. Please check your .env.local file and ensure it contains DATABASE_URL.'\r\n  )\r\n}\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n  })\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\r\n\r\n"],"names":[],"mappings":"AAAA,0BAA0B;AAC1B,0DAA0D;;;;;AAE1D;;AAEA,MAAM,kBAAkB;AAIxB,6BAA6B;AAC7B,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;IAC7B,MAAM,IAAI,MACR;AAEJ;AAEO,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/auth-nextauth.ts"],"sourcesContent":["// NextAuth.js v5 Configuration\r\n// Complete JWT authentication solution using NextAuth.js v5\r\n// NextAuth.js handles sessions, token refresh, and security automatically\r\n\r\nimport type { NextAuthConfig } from 'next-auth'\r\nimport CredentialsProvider from 'next-auth/providers/credentials'\r\nimport { prisma } from '@/lib/prisma'\r\nimport bcrypt from 'bcryptjs'\r\n\r\nexport const authConfig = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: 'Credentials',\r\n      credentials: {\r\n        email: { label: 'Email', type: 'email' },\r\n        password: { label: 'Password', type: 'password' },\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email || !credentials?.password) {\r\n          throw new Error('Email and password are required')\r\n        }\r\n\r\n        // Find user\r\n        const user = await prisma.user.findUnique({\r\n          where: { email: credentials.email },\r\n        })\r\n\r\n        if (!user) {\r\n          throw new Error('Invalid email or password')\r\n        }\r\n\r\n        // Check if user has a password hash (migrated to JWT auth)\r\n        if (!user.passwordHash) {\r\n          throw new Error(\r\n            'This account still uses Supabase authentication. Please contact support to migrate your account.'\r\n          )\r\n        }\r\n\r\n        // Verify password\r\n        const isValidPassword = await bcrypt.compare(\r\n          credentials.password,\r\n          user.passwordHash\r\n        )\r\n        if (!isValidPassword) {\r\n          throw new Error('Invalid email or password')\r\n        }\r\n\r\n        // Update last login\r\n        await prisma.user.update({\r\n          where: { id: user.id },\r\n          data: { lastLogin: new Date() },\r\n        })\r\n\r\n        // Return user object (will be encoded in JWT)\r\n        return {\r\n          id: user.id,\r\n          email: user.email,\r\n          name: `${user.firstName} ${user.lastName}`,\r\n          role: user.role as 'smme' | 'admin',\r\n          approved: user.approved,\r\n        }\r\n      },\r\n    }),\r\n  ],\r\n\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      // Initial sign in - user object is available\r\n      if (user) {\r\n        token.id = user.id\r\n        token.role = (user as any).role\r\n        token.approved = (user as any).approved\r\n      }\r\n      return token\r\n    },\r\n    async session({ session, token }) {\r\n      // Send properties to the client\r\n      if (session.user) {\r\n        session.user.id = token.id as string\r\n        session.user.role = token.role as 'smme' | 'admin'\r\n        session.user.approved = token.approved as boolean\r\n      }\r\n      return session\r\n    },\r\n  },\r\n\r\n  pages: {\r\n    signIn: '/login',\r\n  },\r\n\r\n  session: {\r\n    strategy: 'jwt',\r\n    maxAge: 7 * 24 * 60 * 60, // 7 days\r\n  },\r\n\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n} satisfies NextAuthConfig\r\n\r\n// Type augmentation for NextAuth\r\ndeclare module 'next-auth' {\r\n  interface Session {\r\n    user: {\r\n      id: string\r\n      email: string\r\n      name: string\r\n      role: 'smme' | 'admin'\r\n      approved: boolean\r\n    }\r\n  }\r\n\r\n  interface User {\r\n    id: string\r\n    email: string\r\n    name: string\r\n    role: 'smme' | 'admin'\r\n    approved: boolean\r\n  }\r\n}\r\n\r\ndeclare module 'next-auth/jwt' {\r\n  interface JWT {\r\n    id: string\r\n    role: 'smme' | 'admin'\r\n    approved: boolean\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,+BAA+B;AAC/B,4DAA4D;AAC5D,0EAA0E;;;;;AAG1E;AAAA;AACA;AACA;;;;AAEO,MAAM,aAAa;IACxB,WAAW;QACT,IAAA,iOAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,MAAM,IAAI,MAAM;gBAClB;gBAEA,YAAY;gBACZ,MAAM,OAAO,MAAM,uHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE,OAAO,YAAY,KAAK;oBAAC;gBACpC;gBAEA,IAAI,CAAC,MAAM;oBACT,MAAM,IAAI,MAAM;gBAClB;gBAEA,2DAA2D;gBAC3D,IAAI,CAAC,KAAK,YAAY,EAAE;oBACtB,MAAM,IAAI,MACR;gBAEJ;gBAEA,kBAAkB;gBAClB,MAAM,kBAAkB,MAAM,iMAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,YAAY;gBAEnB,IAAI,CAAC,iBAAiB;oBACpB,MAAM,IAAI,MAAM;gBAClB;gBAEA,oBAAoB;gBACpB,MAAM,uHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;oBACvB,OAAO;wBAAE,IAAI,KAAK,EAAE;oBAAC;oBACrB,MAAM;wBAAE,WAAW,IAAI;oBAAO;gBAChC;gBAEA,8CAA8C;gBAC9C,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,GAAG,KAAK,SAAS,CAAC,CAAC,EAAE,KAAK,QAAQ,EAAE;oBAC1C,MAAM,KAAK,IAAI;oBACf,UAAU,KAAK,QAAQ;gBACzB;YACF;QACF;KACD;IAED,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,6CAA6C;YAC7C,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;gBAC/B,MAAM,QAAQ,GAAG,AAAC,KAAa,QAAQ;YACzC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,gCAAgC;YAChC,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;gBAC9B,QAAQ,IAAI,CAAC,QAAQ,GAAG,MAAM,QAAQ;YACxC;YACA,OAAO;QACT;IACF;IAEA,OAAO;QACL,QAAQ;IACV;IAEA,SAAS;QACP,UAAU;QACV,QAAQ,IAAI,KAAK,KAAK;IACxB;IAEA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/auth.ts"],"sourcesContent":["// NextAuth.js v5 exports and shared auth types\n// This file provides both NextAuth functions and the AuthUser type used throughout the app\n\nimport NextAuth from 'next-auth'\nimport { authConfig } from './auth-nextauth'\nimport type { UserRole } from './db-schema'\n\n// Create NextAuth instance for server-side use\nconst nextAuth = NextAuth(authConfig)\n\n// Export NextAuth functions for server-side use\nexport const { auth, signIn, signOut } = nextAuth\n\n// Export AuthUser type used throughout the application\nexport interface AuthUser {\n  id: string\n  email: string\n  role: UserRole\n  name: string\n  approved: boolean\n}\n"],"names":[],"mappings":"AAAA,+CAA+C;AAC/C,2FAA2F;;;;;;;;;AAE3F;AACA;;;AAGA,+CAA+C;AAC/C,MAAM,WAAW,IAAA,4QAAQ,EAAC,qIAAU;AAG7B,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/auth-nextauth-helpers.ts"],"sourcesContent":["// Server-side NextAuth.js helpers\r\n// These replace Supabase auth helpers for server components\r\n\r\nimport { auth } from '@/lib/auth'\r\nimport { redirect } from 'next/navigation'\r\nimport type { AuthUser } from '@/lib/auth'\r\n\r\n/**\r\n * Get the current session on the server\r\n * Returns null if not authenticated\r\n */\r\nexport async function getServerSession(): Promise<AuthUser | null> {\r\n  const session = await auth()\r\n\r\n  if (!session?.user) {\r\n    return null\r\n  }\r\n\r\n  return {\r\n    id: session.user.id,\r\n    email: session.user.email,\r\n    role: session.user.role,\r\n    name: session.user.name,\r\n    approved: session.user.approved,\r\n  }\r\n}\r\n\r\n/**\r\n * Require authentication - redirects to login if not authenticated\r\n */\r\nexport async function requireAuth(): Promise<AuthUser> {\r\n  const session = await getServerSession()\r\n\r\n  if (!session) {\r\n    redirect('/login')\r\n  }\r\n\r\n  return session\r\n}\r\n\r\n/**\r\n * Require admin role - redirects to login if not authenticated, or dashboard if not admin\r\n */\r\nexport async function requireAdmin(): Promise<AuthUser> {\r\n  const session = await getServerSession()\r\n\r\n  if (!session) {\r\n    redirect('/login')\r\n  }\r\n\r\n  if (session.role !== 'admin') {\r\n    redirect('/dashboard')\r\n  }\r\n\r\n  return session\r\n}\r\n"],"names":[],"mappings":"AAAA,kCAAkC;AAClC,4DAA4D;;;;;;;;;AAE5D;AACA;AAAA;;;AAOO,eAAe;IACpB,MAAM,UAAU,MAAM,IAAA,mHAAI;IAE1B,IAAI,CAAC,SAAS,MAAM;QAClB,OAAO;IACT;IAEA,OAAO;QACL,IAAI,QAAQ,IAAI,CAAC,EAAE;QACnB,OAAO,QAAQ,IAAI,CAAC,KAAK;QACzB,MAAM,QAAQ,IAAI,CAAC,IAAI;QACvB,MAAM,QAAQ,IAAI,CAAC,IAAI;QACvB,UAAU,QAAQ,IAAI,CAAC,QAAQ;IACjC;AACF;AAKO,eAAe;IACpB,MAAM,UAAU,MAAM;IAEtB,IAAI,CAAC,SAAS;QACZ,IAAA,gUAAQ,EAAC;IACX;IAEA,OAAO;AACT;AAKO,eAAe;IACpB,MAAM,UAAU,MAAM;IAEtB,IAAI,CAAC,SAAS;QACZ,IAAA,gUAAQ,EAAC;IACX;IAEA,IAAI,QAAQ,IAAI,KAAK,SAAS;QAC5B,IAAA,gUAAQ,EAAC;IACX;IAEA,OAAO;AACT"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/supabase/auth-helpers.ts"],"sourcesContent":["// Server-side auth helpers - Now using NextAuth.js\n// This file maintains the same interface for backward compatibility\n// but uses NextAuth.js instead of Supabase Auth\n\nimport { redirect } from 'next/navigation'\nimport { getServerSession as getNextAuthSession, requireAuth as requireNextAuth, requireAdmin as requireNextAuthAdmin } from '@/lib/auth-nextauth-helpers'\nimport type { AuthUser } from '@/lib/auth'\n\n/**\n * Get the current session on the server\n * Returns null if not authenticated\n * Now uses NextAuth.js instead of Supabase\n */\nexport async function getServerSession(): Promise<AuthUser | null> {\n  return await getNextAuthSession()\n}\n\n/**\n * Require authentication - redirects to login if not authenticated\n * Now uses NextAuth.js instead of Supabase\n */\nexport async function requireAuth(): Promise<AuthUser> {\n  return await requireNextAuth()\n}\n\n/**\n * Require admin role - redirects to login if not authenticated, or dashboard if not admin\n * Now uses NextAuth.js instead of Supabase\n */\nexport async function requireAdmin(): Promise<AuthUser> {\n  return await requireNextAuthAdmin()\n}\n"],"names":[],"mappings":"AAAA,mDAAmD;AACnD,oEAAoE;AACpE,gDAAgD;;;;;;;;;AAGhD;;AAQO,eAAe;IACpB,OAAO,MAAM,IAAA,sJAAkB;AACjC;AAMO,eAAe;IACpB,OAAO,MAAM,IAAA,iJAAe;AAC9B;AAMO,eAAe;IACpB,OAAO,MAAM,IAAA,kJAAoB;AACnC"}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/db/field-mapper.ts"],"sourcesContent":["// Field name mapper: snake_case (validation) <-> camelCase (Prisma)\r\n// Converts between database column names (snake_case) and Prisma model fields (camelCase)\r\n\r\n/**\r\n * Convert snake_case to camelCase\r\n */\r\nfunction snakeToCamel(str: string): string {\r\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())\r\n}\r\n\r\n/**\r\n * Convert camelCase to snake_case\r\n */\r\nfunction camelToSnake(str: string): string {\r\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\r\n}\r\n\r\n/**\r\n * Transform object keys from snake_case to camelCase\r\n */\r\nexport function toPrismaFormat<T extends Record<string, any>>(data: T): any {\r\n  if (!data || typeof data !== 'object') return data\r\n\r\n  if (Array.isArray(data)) {\r\n    return data.map(item => toPrismaFormat(item))\r\n  }\r\n\r\n  const transformed: any = {}\r\n  for (const [key, value] of Object.entries(data)) {\r\n    const camelKey = snakeToCamel(key)\r\n    \r\n    // Handle nested objects (like funding_requirements)\r\n    if (value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {\r\n      transformed[camelKey] = toPrismaFormat(value)\r\n    } else {\r\n      transformed[camelKey] = value\r\n    }\r\n  }\r\n  \r\n  return transformed\r\n}\r\n\r\n/**\r\n * Transform object keys from camelCase to snake_case\r\n */\r\nexport function fromPrismaFormat<T extends Record<string, any>>(data: T): any {\r\n  if (!data || typeof data !== 'object') return data\r\n\r\n  if (Array.isArray(data)) {\r\n    return data.map(item => fromPrismaFormat(item))\r\n  }\r\n\r\n  const transformed: any = {}\r\n  for (const [key, value] of Object.entries(data)) {\r\n    const snakeKey = camelToSnake(key)\r\n    \r\n    // Handle nested objects\r\n    if (value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {\r\n      transformed[snakeKey] = fromPrismaFormat(value)\r\n    } else {\r\n      transformed[snakeKey] = value\r\n    }\r\n  }\r\n  \r\n  return transformed\r\n}\r\n\r\n/**\r\n * User profile field mapping: validation (snake_case) -> Prisma (camelCase)\r\n */\r\nexport const userProfileFieldMap: Record<string, string> = {\r\n  company_name: 'companyName',\r\n  registration_number: 'registrationNumber',\r\n  business_description: 'businessDescription',\r\n  annual_revenue: 'annualRevenue',\r\n  employees_count: 'employeesCount',\r\n  years_in_business: 'yearsInBusiness',\r\n  funding_requirements: 'fundingRequirements',\r\n}\r\n\r\n/**\r\n * Transform user profile data from validation format to Prisma format\r\n */\r\nexport function transformUserProfileToPrisma(data: any): any {\r\n  if (!data || typeof data !== 'object') return data\r\n\r\n  const transformed: any = {}\r\n  \r\n  for (const [key, value] of Object.entries(data)) {\r\n    const prismaKey = userProfileFieldMap[key] || snakeToCamel(key)\r\n    \r\n    // Special handling for nested objects\r\n    if (key === 'funding_requirements' && value && typeof value === 'object') {\r\n      transformed[prismaKey] = value // Keep as-is (already in correct format)\r\n    } else {\r\n      transformed[prismaKey] = value\r\n    }\r\n  }\r\n  \r\n  return transformed\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,oEAAoE;AACpE,0FAA0F;AAE1F;;CAEC;;;;;;;;;;AACD,SAAS,aAAa,GAAW;IAC/B,OAAO,IAAI,OAAO,CAAC,aAAa,CAAC,GAAG,SAAW,OAAO,WAAW;AACnE;AAEA;;CAEC,GACD,SAAS,aAAa,GAAW;IAC/B,OAAO,IAAI,OAAO,CAAC,UAAU,CAAC,SAAW,CAAC,CAAC,EAAE,OAAO,WAAW,IAAI;AACrE;AAKO,SAAS,eAA8C,IAAO;IACnE,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU,OAAO;IAE9C,IAAI,MAAM,OAAO,CAAC,OAAO;QACvB,OAAO,KAAK,GAAG,CAAC,CAAA,OAAQ,eAAe;IACzC;IAEA,MAAM,cAAmB,CAAC;IAC1B,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,MAAO;QAC/C,MAAM,WAAW,aAAa;QAE9B,oDAAoD;QACpD,IAAI,SAAS,OAAO,UAAU,YAAY,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,CAAC,iBAAiB,IAAI,GAAG;YAC3F,WAAW,CAAC,SAAS,GAAG,eAAe;QACzC,OAAO;YACL,WAAW,CAAC,SAAS,GAAG;QAC1B;IACF;IAEA,OAAO;AACT;AAKO,SAAS,iBAAgD,IAAO;IACrE,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU,OAAO;IAE9C,IAAI,MAAM,OAAO,CAAC,OAAO;QACvB,OAAO,KAAK,GAAG,CAAC,CAAA,OAAQ,iBAAiB;IAC3C;IAEA,MAAM,cAAmB,CAAC;IAC1B,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,MAAO;QAC/C,MAAM,WAAW,aAAa;QAE9B,wBAAwB;QACxB,IAAI,SAAS,OAAO,UAAU,YAAY,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,CAAC,iBAAiB,IAAI,GAAG;YAC3F,WAAW,CAAC,SAAS,GAAG,iBAAiB;QAC3C,OAAO;YACL,WAAW,CAAC,SAAS,GAAG;QAC1B;IACF;IAEA,OAAO;AACT;AAKO,MAAM,sBAA8C;IACzD,cAAc;IACd,qBAAqB;IACrB,sBAAsB;IACtB,gBAAgB;IAChB,iBAAiB;IACjB,mBAAmB;IACnB,sBAAsB;AACxB;AAKO,SAAS,6BAA6B,IAAS;IACpD,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU,OAAO;IAE9C,MAAM,cAAmB,CAAC;IAE1B,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,MAAO;QAC/C,MAAM,YAAY,mBAAmB,CAAC,IAAI,IAAI,aAAa;QAE3D,sCAAsC;QACtC,IAAI,QAAQ,0BAA0B,SAAS,OAAO,UAAU,UAAU;YACxE,WAAW,CAAC,UAAU,GAAG,OAAM,yCAAyC;QAC1E,OAAO;YACL,WAAW,CAAC,UAAU,GAAG;QAC3B;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/db/serialize.ts"],"sourcesContent":["// Utility to serialize Prisma data for client components\r\n// Converts Decimal objects to numbers, Dates to strings, etc.\r\n\r\n/**\r\n * Check if value is a Prisma Decimal\r\n * Prisma Decimal has toNumber() and toString() methods\r\n */\r\nfunction isDecimal(value: any): boolean {\r\n  return value != null && \r\n         typeof value === 'object' && \r\n         typeof value.toNumber === 'function' &&\r\n         typeof value.toString === 'function' &&\r\n         !(value instanceof Date)\r\n}\r\n\r\n/**\r\n * Serialize a Prisma UserProfile for client components\r\n * Converts Decimal and other non-serializable types\r\n */\r\nexport function serializeUserProfile(profile: any) {\r\n  if (!profile) return null\r\n\r\n  return {\r\n    ...profile,\r\n    annualRevenue: decimalToNumber(profile.annualRevenue),\r\n    // Keep other fields as-is\r\n  }\r\n}\r\n\r\n/**\r\n * Serialize any Prisma result for client components\r\n * Recursively converts Decimal values\r\n */\r\nexport function serializePrismaResult<T>(data: T): T {\r\n  if (data === null || data === undefined) return data\r\n\r\n  if (Array.isArray(data)) {\r\n    return data.map(serializePrismaResult) as T\r\n  }\r\n\r\n  if (isDecimal(data)) {\r\n    return (data as any).toNumber() as T\r\n  }\r\n\r\n  if (data instanceof Date) {\r\n    return data.toISOString() as T\r\n  }\r\n\r\n  if (typeof data === 'object') {\r\n    const serialized: any = {}\r\n    for (const [key, value] of Object.entries(data)) {\r\n      serialized[key] = serializePrismaResult(value)\r\n    }\r\n    return serialized as T\r\n  }\r\n\r\n  return data\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA,yDAAyD;AACzD,8DAA8D;AAE9D;;;CAGC;;;;;;AACD,SAAS,UAAU,KAAU;IAC3B,OAAO,SAAS,QACT,OAAO,UAAU,YACjB,OAAO,MAAM,QAAQ,KAAK,cAC1B,OAAO,MAAM,QAAQ,KAAK,cAC1B,CAAC,CAAC,iBAAiB,IAAI;AAChC;AAMO,SAAS,qBAAqB,OAAY;IAC/C,IAAI,CAAC,SAAS,OAAO;IAErB,OAAO;QACL,GAAG,OAAO;QACV,eAAe,gBAAgB,QAAQ,aAAa;IAEtD;AACF;AAMO,SAAS,sBAAyB,IAAO;IAC9C,IAAI,SAAS,QAAQ,SAAS,WAAW,OAAO;IAEhD,IAAI,MAAM,OAAO,CAAC,OAAO;QACvB,OAAO,KAAK,GAAG,CAAC;IAClB;IAEA,IAAI,UAAU,OAAO;QACnB,OAAO,AAAC,KAAa,QAAQ;IAC/B;IAEA,IAAI,gBAAgB,MAAM;QACxB,OAAO,KAAK,WAAW;IACzB;IAEA,IAAI,OAAO,SAAS,UAAU;QAC5B,MAAM,aAAkB,CAAC;QACzB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,MAAO;YAC/C,UAAU,CAAC,IAAI,GAAG,sBAAsB;QAC1C;QACA,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 368, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/db/queries.ts"],"sourcesContent":["// Prisma Query Helpers - Production Ready\r\n// Migrated from Supabase to Prisma with best practices\r\n// \r\n// Key improvements:\r\n// - Full type safety with Prisma generated types\r\n// - Consistent error handling\r\n// - Better performance with optimized queries\r\n// - Clearer, more maintainable code\r\n// - No RLS restrictions - access control handled in application code\r\n\r\nimport { prisma } from '@/lib/prisma'\r\nimport type { Prisma } from '@prisma/client'\r\nimport { transformUserProfileToPrisma } from './field-mapper'\r\nimport { serializePrismaResult } from './serialize'\r\n\r\n/**\r\n * Generic result type for all queries\r\n */\r\nexport type QueryResult<T> = {\r\n  success: boolean\r\n  data?: T\r\n  error?: string\r\n  code?: string\r\n}\r\n\r\n/**\r\n * Prisma error handler - maps Prisma errors to consistent format\r\n */\r\nfunction handlePrismaError<T>(error: any): QueryResult<T> {\r\n  // Record not found (P2025)\r\n  if (error?.code === 'P2025') {\r\n    return { success: false, error: 'Record not found', code: 'NOT_FOUND' }\r\n  }\r\n  \r\n  // Unique constraint violation (P2002)\r\n  if (error?.code === 'P2002') {\r\n    const field = error.meta?.target?.[0] || 'field'\r\n    return { \r\n      success: false, \r\n      error: `Record with this ${field} already exists`, \r\n      code: 'DUPLICATE' \r\n    }\r\n  }\r\n  \r\n  // Foreign key constraint violation (P2003)\r\n  if (error?.code === 'P2003') {\r\n    return { \r\n      success: false, \r\n      error: 'Referenced record does not exist', \r\n      code: 'FOREIGN_KEY' \r\n    }\r\n  }\r\n  \r\n  // Generic error\r\n  return {\r\n    success: false,\r\n    error: error?.message || 'Database operation failed',\r\n    code: error?.code,\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// USER PROFILE QUERIES\r\n// ============================================================================\r\n\r\nexport const userProfileQueries = {\r\n  /**\r\n   * Get user profile by user ID\r\n   */\r\n  async getByUserId(\r\n    userId: string\r\n  ): Promise<QueryResult<Prisma.UserProfileGetPayload<{}>>> {\r\n    try {\r\n      const profile = await prisma.userProfile.findUnique({\r\n        where: { userId },\r\n      })\r\n\r\n      if (!profile) {\r\n        return { success: false, error: 'Profile not found', code: 'NOT_FOUND' }\r\n      }\r\n\r\n      // Serialize Decimal values for client components\r\n      return { success: true, data: serializePrismaResult(profile) }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Upsert user profile (create or update)\r\n   * Transforms snake_case validation data to camelCase Prisma format\r\n   */\r\n  async upsert(\r\n    userId: string,\r\n    profile: any // Accept any for flexibility, validated by caller (snake_case format)\r\n  ): Promise<QueryResult<Prisma.UserProfileGetPayload<{}>>> {\r\n    try {\r\n      // Transform from validation format (snake_case) to Prisma format (camelCase)\r\n      const prismaProfile = transformUserProfileToPrisma(profile)\r\n      \r\n      const result = await prisma.userProfile.upsert({\r\n        where: { userId },\r\n        update: prismaProfile as Prisma.UserProfileUpdateInput,\r\n        create: {\r\n          userId,\r\n          ...prismaProfile,\r\n        } as Prisma.UserProfileCreateInput,\r\n      })\r\n\r\n      // Serialize Decimal values for client components\r\n      return { success: true, data: serializePrismaResult(result) }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update user profile (partial update)\r\n   * Transforms snake_case validation data to camelCase Prisma format\r\n   */\r\n  async update(\r\n    userId: string,\r\n    updates: any // Accept any for flexibility (snake_case or camelCase)\r\n  ): Promise<QueryResult<Prisma.UserProfileGetPayload<{}>>> {\r\n    try {\r\n      // Transform from validation format (snake_case) to Prisma format (camelCase)\r\n      const prismaUpdates = transformUserProfileToPrisma(updates)\r\n      \r\n      const profile = await prisma.userProfile.update({\r\n        where: { userId },\r\n        data: prismaUpdates as Prisma.UserProfileUpdateInput,\r\n      })\r\n\r\n      // Serialize Decimal values for client components\r\n      return { success: true, data: serializePrismaResult(profile) }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if profile is complete (has all required onboarding data)\r\n   */\r\n  async isComplete(userId: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.getByUserId(userId)\r\n      if (!result.success || !result.data) return false\r\n\r\n      const profile = result.data\r\n\r\n      // Check required fields\r\n      const required = [\r\n        profile.companyName,\r\n        profile.registrationNumber,\r\n        profile.industry,\r\n        profile.businessDescription,\r\n        profile.location,\r\n        profile.annualRevenue,\r\n        profile.employeesCount,\r\n        profile.yearsInBusiness,\r\n        profile.fundingRequirements,\r\n      ]\r\n\r\n      if (required.some(field => field === null || field === undefined || field === '')) {\r\n        return false\r\n      }\r\n\r\n      // Validate funding_requirements structure\r\n      const fundingReqs = profile.fundingRequirements as any\r\n      if (!fundingReqs?.amount_needed || !fundingReqs?.funding_purpose) {\r\n        return false\r\n      }\r\n\r\n      return true\r\n    } catch {\r\n      return false\r\n    }\r\n  },\r\n}\r\n\r\n// ============================================================================\r\n// USER QUERIES\r\n// ============================================================================\r\n\r\nexport const userQueries = {\r\n  /**\r\n   * Get all users (admin only - caller must verify admin status)\r\n   */\r\n  async getAll(): Promise<QueryResult<Prisma.UserGetPayload<{}>[]>> {\r\n    try {\r\n      const users = await prisma.user.findMany({\r\n        orderBy: {\r\n          createdAt: 'desc',\r\n        },\r\n      })\r\n\r\n      return { success: true, data: users }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get user by ID\r\n   */\r\n  async getById(\r\n    userId: string\r\n  ): Promise<QueryResult<Prisma.UserGetPayload<{}>>> {\r\n    try {\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n      })\r\n\r\n      if (!user) {\r\n        return { success: false, error: 'User not found', code: 'NOT_FOUND' }\r\n      }\r\n\r\n      return { success: true, data: user }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get user by email\r\n   */\r\n  async getByEmail(\r\n    email: string\r\n  ): Promise<QueryResult<Prisma.UserGetPayload<{}>>> {\r\n    try {\r\n      const user = await prisma.user.findUnique({\r\n        where: { email },\r\n      })\r\n\r\n      if (!user) {\r\n        return { success: false, error: 'User not found', code: 'NOT_FOUND' }\r\n      }\r\n\r\n      return { success: true, data: user }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update user approval status\r\n   */\r\n  async updateApproval(\r\n    userId: string,\r\n    approved: boolean\r\n  ): Promise<QueryResult<Prisma.UserGetPayload<{}>>> {\r\n    try {\r\n      const user = await prisma.user.update({\r\n        where: { id: userId },\r\n        data: { approved },\r\n      })\r\n\r\n      return { success: true, data: user }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update user last login timestamp\r\n   */\r\n  async updateLastLogin(\r\n    userId: string\r\n  ): Promise<QueryResult<Prisma.UserGetPayload<{}>>> {\r\n    try {\r\n      const user = await prisma.user.update({\r\n        where: { id: userId },\r\n        data: { lastLogin: new Date() },\r\n      })\r\n\r\n      return { success: true, data: user }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n}\r\n\r\n// ============================================================================\r\n// FUNDING OPPORTUNITY QUERIES\r\n// ============================================================================\r\n\r\nexport const opportunityQueries = {\r\n  /**\r\n   * Get all opportunities\r\n   */\r\n  async getAll(): Promise<QueryResult<Prisma.FundingOpportunityGetPayload<{}>[]>> {\r\n    try {\r\n      const opportunities = await prisma.fundingOpportunity.findMany({\r\n        orderBy: {\r\n          createdAt: 'desc',\r\n        },\r\n      })\r\n\r\n      return { success: true, data: opportunities }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get opportunity by ID\r\n   */\r\n  async getById(\r\n    opportunityId: string\r\n  ): Promise<QueryResult<Prisma.FundingOpportunityGetPayload<{}>>> {\r\n    try {\r\n      const opportunity = await prisma.fundingOpportunity.findUnique({\r\n        where: { id: opportunityId },\r\n      })\r\n\r\n      if (!opportunity) {\r\n        return {\r\n          success: false,\r\n          error: 'Opportunity not found',\r\n          code: 'NOT_FOUND',\r\n        }\r\n      }\r\n\r\n      return { success: true, data: opportunity }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get opportunities by industry\r\n   */\r\n  async getByIndustry(\r\n    industry: string\r\n  ): Promise<QueryResult<Prisma.FundingOpportunityGetPayload<{}>[]>> {\r\n    try {\r\n      const opportunities = await prisma.fundingOpportunity.findMany({\r\n        where: {\r\n          industryFocus: {\r\n            has: industry, // Array contains\r\n          },\r\n        },\r\n        orderBy: {\r\n          createdAt: 'desc',\r\n        },\r\n      })\r\n\r\n      return { success: true, data: opportunities }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get active opportunities (deadline in future)\r\n   */\r\n  async getActive(): Promise<QueryResult<Prisma.FundingOpportunityGetPayload<{}>[]>> {\r\n    try {\r\n      const now = new Date()\r\n      const opportunities = await prisma.fundingOpportunity.findMany({\r\n        where: {\r\n          deadline: {\r\n            gt: now,\r\n          },\r\n        },\r\n        orderBy: {\r\n          deadline: 'asc',\r\n        },\r\n      })\r\n\r\n      return { success: true, data: opportunities }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n}\r\n\r\n// ============================================================================\r\n// MATCH QUERIES\r\n// ============================================================================\r\n\r\nexport const matchQueries = {\r\n  /**\r\n   * Get matches for user\r\n   */\r\n  async getByUserId(\r\n    userId: string\r\n  ): Promise<QueryResult<Prisma.MatchGetPayload<{}>[]>> {\r\n    try {\r\n      const matches = await prisma.match.findMany({\r\n        where: { userId },\r\n        orderBy: {\r\n          matchScore: 'desc',\r\n        },\r\n      })\r\n\r\n      return { success: true, data: matches }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update match status\r\n   */\r\n  async updateStatus(\r\n    matchId: string,\r\n    status: string // 'new' | 'viewed' | 'interested' | 'applied'\r\n  ): Promise<QueryResult<Prisma.MatchGetPayload<{}>>> {\r\n    try {\r\n      const updateData: Prisma.MatchUpdateInput = { status }\r\n      \r\n      // Set viewed_at when status becomes 'viewed'\r\n      if (status === 'viewed') {\r\n        updateData.viewedAt = new Date()\r\n      }\r\n\r\n      const match = await prisma.match.update({\r\n        where: { id: matchId },\r\n        data: updateData,\r\n      })\r\n\r\n      return { success: true, data: match }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n}\r\n\r\n// ============================================================================\r\n// APPLICATION QUERIES\r\n// ============================================================================\r\n\r\nexport const applicationQueries = {\r\n  /**\r\n   * Get applications for user\r\n   */\r\n  async getByUserId(\r\n    userId: string\r\n  ): Promise<QueryResult<Prisma.ApplicationGetPayload<{}>[]>> {\r\n    try {\r\n      const applications = await prisma.application.findMany({\r\n        where: { userId },\r\n        orderBy: {\r\n          createdAt: 'desc',\r\n        },\r\n      })\r\n\r\n      return { success: true, data: applications }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get application by ID\r\n   */\r\n  async getById(\r\n    applicationId: string\r\n  ): Promise<QueryResult<Prisma.ApplicationGetPayload<{}>>> {\r\n    try {\r\n      const application = await prisma.application.findUnique({\r\n        where: { id: applicationId },\r\n      })\r\n\r\n      if (!application) {\r\n        return {\r\n          success: false,\r\n          error: 'Application not found',\r\n          code: 'NOT_FOUND',\r\n        }\r\n      }\r\n\r\n      return { success: true, data: application }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update application status\r\n   */\r\n  async updateStatus(\r\n    applicationId: string,\r\n    status: string // 'draft' | 'in_review' | 'submitted' | 'approved' | 'rejected'\r\n  ): Promise<QueryResult<Prisma.ApplicationGetPayload<{}>>> {\r\n    try {\r\n      const updateData: Prisma.ApplicationUpdateInput = { status }\r\n\r\n      if (status === 'submitted') {\r\n        updateData.submittedAt = new Date()\r\n      } else if (status === 'approved' || status === 'rejected') {\r\n        updateData.reviewedAt = new Date()\r\n      }\r\n\r\n      const application = await prisma.application.update({\r\n        where: { id: applicationId },\r\n        data: updateData,\r\n      })\r\n\r\n      return { success: true, data: application }\r\n    } catch (error: any) {\r\n      return handlePrismaError(error)\r\n    }\r\n  },\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 859, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/validations/schemas.ts"],"sourcesContent":["// Zod validation schemas for all input types\r\n// These provide runtime validation and type inference\r\n\r\nimport { z } from 'zod'\r\n\r\n// ============================================================================\r\n// USER PROFILE VALIDATION\r\n// ============================================================================\r\n\r\n/**\r\n * Funding requirements schema\r\n */\r\nexport const fundingRequirementsSchema = z.object({\r\n  amount_needed: z.number().min(0, 'Funding amount must be positive'),\r\n  funding_purpose: z.string().min(10, 'Funding purpose must be at least 10 characters').max(2000),\r\n  business_stage: z.enum(['startup', 'growth', 'expansion', 'mature'], {\r\n    errorMap: () => ({ message: 'Business stage must be one of: startup, growth, expansion, mature' })\r\n  }),\r\n  industry_sector: z.array(z.string()).min(1, 'At least one industry sector is required'),\r\n  preferred_funding_type: z.array(z.string()).min(1, 'At least one funding type is required')\r\n})\r\n\r\n/**\r\n * User profile schema for create/update operations\r\n */\r\nexport const userProfileSchema = z.object({\r\n  company_name: z.string()\r\n    .min(1, 'Company name is required')\r\n    .max(255, 'Company name must be less than 255 characters')\r\n    .trim(),\r\n  registration_number: z.string()\r\n    .min(1, 'Registration number is required')\r\n    .max(100, 'Registration number must be less than 100 characters')\r\n    .trim(),\r\n  industry: z.string()\r\n    .min(1, 'Industry is required')\r\n    .max(100, 'Industry must be less than 100 characters')\r\n    .trim(),\r\n  business_description: z.string()\r\n    .min(10, 'Business description must be at least 10 characters')\r\n    .max(2000, 'Business description must be less than 2000 characters')\r\n    .trim(),\r\n  annual_revenue: z.number()\r\n    .min(0, 'Annual revenue must be positive')\r\n    .max(999999999999999, 'Annual revenue is too large'),\r\n  employees_count: z.number()\r\n    .int('Employee count must be a whole number')\r\n    .min(0, 'Employee count must be non-negative')\r\n    .max(1000000, 'Employee count is too large'),\r\n  years_in_business: z.number()\r\n    .int('Years in business must be a whole number')\r\n    .min(0, 'Years in business must be non-negative')\r\n    .max(200, 'Years in business is too large'),\r\n  location: z.string()\r\n    .min(1, 'Location is required')\r\n    .max(255, 'Location must be less than 255 characters')\r\n    .trim(),\r\n  funding_requirements: fundingRequirementsSchema\r\n})\r\n\r\n/**\r\n * Partial update schema (all fields optional)\r\n */\r\nexport const userProfileUpdateSchema = userProfileSchema.partial()\r\n\r\n/**\r\n * Inferred types from schemas\r\n */\r\nexport type UserProfileInput = z.infer<typeof userProfileSchema>\r\nexport type UserProfileUpdateInput = z.infer<typeof userProfileUpdateSchema>\r\nexport type FundingRequirementsInput = z.infer<typeof fundingRequirementsSchema>\r\n\r\n// ============================================================================\r\n// USER REGISTRATION VALIDATION\r\n// ============================================================================\r\n\r\nexport const userRegistrationSchema = z.object({\r\n  email: z.string()\r\n    .email('Invalid email address')\r\n    .max(255, 'Email must be less than 255 characters')\r\n    .toLowerCase()\r\n    .trim(),\r\n  password: z.string()\r\n    .min(8, 'Password must be at least 8 characters')\r\n    .max(100, 'Password must be less than 100 characters')\r\n    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')\r\n    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')\r\n    .regex(/[0-9]/, 'Password must contain at least one number'),\r\n  firstName: z.string()\r\n    .min(1, 'First name is required')\r\n    .max(100, 'First name must be less than 100 characters')\r\n    .trim(),\r\n  lastName: z.string()\r\n    .min(1, 'Last name is required')\r\n    .max(100, 'Last name must be less than 100 characters')\r\n    .trim(),\r\n  phone: z.string()\r\n    .regex(/^\\+?[1-9]\\d{1,14}$/, 'Invalid phone number format')\r\n    .max(20, 'Phone number must be less than 20 characters')\r\n    .trim(),\r\n  role: z.enum(['smme', 'admin']).default('smme')\r\n})\r\n\r\nexport type UserRegistrationInput = z.infer<typeof userRegistrationSchema>\r\n\r\n// ============================================================================\r\n// APPLICATION VALIDATION\r\n// ============================================================================\r\n\r\nexport const applicationSchema = z.object({\r\n  opportunity_id: z.string().uuid('Invalid opportunity ID'),\r\n  match_id: z.string().uuid('Invalid match ID').optional().nullable(),\r\n  status: z.enum(['draft', 'in_review', 'submitted', 'approved', 'rejected']).default('draft'),\r\n  form_data: z.record(z.any()).default({}),\r\n  signature: z.string().min(1, 'Signature is required').optional()\r\n})\r\n\r\nexport const applicationUpdateSchema = z.object({\r\n  status: z.enum(['draft', 'in_review', 'submitted', 'approved', 'rejected']).optional(),\r\n  form_data: z.record(z.any()).optional(),\r\n  signature: z.string().optional(),\r\n  outcome: z.enum(['approved', 'rejected']).optional(),\r\n  outcome_reason: z.string().optional()\r\n})\r\n\r\nexport type ApplicationInput = z.infer<typeof applicationSchema>\r\nexport type ApplicationUpdateInput = z.infer<typeof applicationUpdateSchema>\r\n\r\n// ============================================================================\r\n// FUNDING OPPORTUNITY VALIDATION\r\n// ============================================================================\r\n\r\nexport const fundingOpportunitySchema = z.object({\r\n  funder_name: z.string()\r\n    .min(1, 'Funder name is required')\r\n    .max(255, 'Funder name must be less than 255 characters')\r\n    .trim(),\r\n  program_name: z.string()\r\n    .min(1, 'Program name is required')\r\n    .max(255, 'Program name must be less than 255 characters')\r\n    .trim(),\r\n  description: z.string()\r\n    .min(10, 'Description must be at least 10 characters')\r\n    .max(5000, 'Description must be less than 5000 characters')\r\n    .trim(),\r\n  amount_range_min: z.number()\r\n    .min(0, 'Minimum amount must be positive')\r\n    .max(999999999999999, 'Amount is too large'),\r\n  amount_range_max: z.number()\r\n    .min(0, 'Maximum amount must be positive')\r\n    .max(999999999999999, 'Amount is too large'),\r\n  eligibility_criteria: z.array(z.string())\r\n    .min(1, 'At least one eligibility criterion is required')\r\n    .max(50, 'Too many eligibility criteria'),\r\n  application_url: z.string()\r\n    .url('Invalid application URL')\r\n    .max(500, 'URL must be less than 500 characters'),\r\n  deadline: z.string()\r\n    .datetime('Invalid deadline format (must be ISO 8601)')\r\n    .refine((date) => new Date(date) > new Date(), {\r\n      message: 'Deadline must be in the future'\r\n    }),\r\n  industry_focus: z.array(z.string())\r\n    .min(1, 'At least one industry focus is required')\r\n    .max(50, 'Too many industry focuses'),\r\n  funding_type: z.string()\r\n    .min(1, 'Funding type is required')\r\n    .max(100, 'Funding type must be less than 100 characters')\r\n    .trim(),\r\n  requirements: z.array(z.string())\r\n    .min(1, 'At least one requirement is required')\r\n    .max(50, 'Too many requirements')\r\n}).refine((data) => data.amount_range_max >= data.amount_range_min, {\r\n  message: 'Maximum amount must be greater than or equal to minimum amount',\r\n  path: ['amount_range_max']\r\n})\r\n\r\nexport type FundingOpportunityInput = z.infer<typeof fundingOpportunitySchema>\r\n\r\n// ============================================================================\r\n// MATCH VALIDATION\r\n// ============================================================================\r\n\r\nexport const matchSchema = z.object({\r\n  user_id: z.string().uuid('Invalid user ID'),\r\n  opportunity_id: z.string().uuid('Invalid opportunity ID'),\r\n  match_score: z.number()\r\n    .int('Match score must be a whole number')\r\n    .min(0, 'Match score must be between 0 and 100')\r\n    .max(100, 'Match score must be between 0 and 100'),\r\n  match_reasons: z.array(z.string())\r\n    .min(1, 'At least one match reason is required')\r\n    .max(20, 'Too many match reasons'),\r\n  status: z.enum(['new', 'viewed', 'interested', 'applied']).default('new')\r\n})\r\n\r\nexport type MatchInput = z.infer<typeof matchSchema>\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 985, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/lib/validations/helpers.ts"],"sourcesContent":["// Validation helper functions\r\n// These provide utilities for validating data with Zod\r\n\r\nimport { z } from 'zod'\r\nimport type { ZodError } from 'zod'\r\n\r\n/**\r\n * Format Zod errors into a user-friendly string\r\n */\r\nexport function formatZodError(error: ZodError): string {\r\n  return error.errors\r\n    .map(err => {\r\n      const path = err.path.join('.')\r\n      return path ? `${path}: ${err.message}` : err.message\r\n    })\r\n    .join(', ')\r\n}\r\n\r\n/**\r\n * Validate data against a Zod schema\r\n * Returns a result object with success flag and either data or error\r\n */\r\nexport function validateWithZod<T>(\r\n  schema: z.ZodSchema<T>,\r\n  data: unknown\r\n): { success: true; data: T } | { success: false; error: string } {\r\n  try {\r\n    const validated = schema.parse(data)\r\n    return { success: true, data: validated }\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return { success: false, error: formatZodError(error) }\r\n    }\r\n    return { success: false, error: 'Validation failed' }\r\n  }\r\n}\r\n\r\n/**\r\n * Safe parse - returns the result object directly from Zod\r\n * Useful when you want more control over error handling\r\n */\r\nexport function safeParseWithZod<T>(\r\n  schema: z.ZodSchema<T>,\r\n  data: unknown\r\n): z.SafeParseReturnType<unknown, T> {\r\n  return schema.safeParse(data)\r\n}\r\n\r\n/**\r\n * Validate and transform data\r\n * Useful for cleaning/transforming input data during validation\r\n */\r\nexport function validateAndTransform<T>(\r\n  schema: z.ZodSchema<T>,\r\n  data: unknown\r\n): { success: true; data: T } | { success: false; error: string } {\r\n  const result = schema.safeParse(data)\r\n  \r\n  if (result.success) {\r\n    return { success: true, data: result.data }\r\n  } else {\r\n    return { success: false, error: formatZodError(result.error) }\r\n  }\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"AAAA,8BAA8B;AAC9B,uDAAuD;;;;;;;;;;;AAEvD;;AAMO,SAAS,eAAe,KAAe;IAC5C,OAAO,MAAM,MAAM,CAChB,GAAG,CAAC,CAAA;QACH,MAAM,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC;QAC3B,OAAO,OAAO,GAAG,KAAK,EAAE,EAAE,IAAI,OAAO,EAAE,GAAG,IAAI,OAAO;IACvD,GACC,IAAI,CAAC;AACV;AAMO,SAAS,gBACd,MAAsB,EACtB,IAAa;IAEb,IAAI;QACF,MAAM,YAAY,OAAO,KAAK,CAAC;QAC/B,OAAO;YAAE,SAAS;YAAM,MAAM;QAAU;IAC1C,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,yNAAC,CAAC,QAAQ,EAAE;YAC/B,OAAO;gBAAE,SAAS;gBAAO,OAAO,eAAe;YAAO;QACxD;QACA,OAAO;YAAE,SAAS;YAAO,OAAO;QAAoB;IACtD;AACF;AAMO,SAAS,iBACd,MAAsB,EACtB,IAAa;IAEb,OAAO,OAAO,SAAS,CAAC;AAC1B;AAMO,SAAS,qBACd,MAAsB,EACtB,IAAa;IAEb,MAAM,SAAS,OAAO,SAAS,CAAC;IAEhC,IAAI,OAAO,OAAO,EAAE;QAClB,OAAO;YAAE,SAAS;YAAM,MAAM,OAAO,IAAI;QAAC;IAC5C,OAAO;QACL,OAAO;YAAE,SAAS;YAAO,OAAO,eAAe,OAAO,KAAK;QAAE;IAC/D;AACF"}},
    {"offset": {"line": 1046, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/app/actions/user-profiles.ts"],"sourcesContent":["'use server'\n\nimport { getServerSession } from '@/lib/supabase/auth-helpers'\nimport { userProfileQueries } from '@/lib/db/queries'\nimport { userProfileSchema, userProfileUpdateSchema } from '@/lib/validations/schemas'\nimport { validateWithZod } from '@/lib/validations/helpers'\nimport type { FundingRequirements } from '@/lib/db-schema'\nimport type { UserProfileResponse } from './types'\n\n/**\n * Input type for creating/updating user profile\n * @deprecated Use UserProfileInput from lib/validations/schemas instead\n * Kept for backward compatibility\n */\nexport interface UserProfileInput {\n  company_name: string\n  registration_number: string\n  industry: string\n  business_description: string\n  annual_revenue: number\n  employees_count: number\n  years_in_business: number\n  location: string\n  funding_requirements: FundingRequirements\n}\n\n// Re-export for convenience\nexport type { UserProfileInput as UserProfileInputType } from '@/lib/validations/schemas'\nexport type { UserProfileResponse }\n\n/**\n * Get user's profile from database\n */\nexport async function getUserProfile(): Promise<UserProfileResponse> {\n  try {\n    // Check authentication\n    const user = await getServerSession()\n    if (!user) {\n      return { success: false, error: 'Authentication required. Please log in.' }\n    }\n\n    // Use optimized query helper\n    const result = await userProfileQueries.getByUserId(user.id)\n    return result\n  } catch (error: any) {\n    // Check if this is a Next.js redirect error - if so, re-throw it\n    if (error && typeof error === 'object' && 'digest' in error && error.digest?.startsWith('NEXT_REDIRECT')) {\n      throw error\n    }\n    console.error('Error in getUserProfile:', error)\n    return { success: false, error: error.message || 'Failed to fetch profile' }\n  }\n}\n\n/**\n * Create a new user profile\n */\nexport async function createUserProfile(input: UserProfileInput): Promise<UserProfileResponse> {\n  try {\n    // Validate input with Zod\n    const validation = validateWithZod(userProfileSchema, input)\n    if (!validation.success) {\n      return { success: false, error: validation.error }\n    }\n\n    // Check authentication\n    const user = await getServerSession()\n    if (!user) {\n      return { success: false, error: 'Authentication required. Please log in.' }\n    }\n\n    // Use optimized query helper\n    const result = await userProfileQueries.upsert(user.id, validation.data)\n    return result\n  } catch (error: any) {\n    // Check if this is a Next.js redirect error - if so, re-throw it\n    if (error && typeof error === 'object' && 'digest' in error && error.digest?.startsWith('NEXT_REDIRECT')) {\n      throw error\n    }\n    console.error('Error in createUserProfile:', error)\n    return { success: false, error: error.message || 'Failed to create profile' }\n  }\n}\n\n/**\n * Update existing user profile\n */\nexport async function updateUserProfile(input: Partial<UserProfileInput>): Promise<UserProfileResponse> {\n  try {\n    // Validate input with Zod (partial schema)\n    const validation = validateWithZod(userProfileUpdateSchema, input)\n    if (!validation.success) {\n      return { success: false, error: validation.error }\n    }\n\n    // Check authentication\n    const user = await getServerSession()\n    if (!user) {\n      return { success: false, error: 'Authentication required. Please log in.' }\n    }\n\n    // Check if profile exists\n    const existingResult = await userProfileQueries.getByUserId(user.id)\n    \n    if (existingResult.success && existingResult.data) {\n      // Update existing profile\n      const result = await userProfileQueries.update(user.id, validation.data)\n      return result\n    } else {\n      // Create new profile if doesn't exist (upsert behavior)\n      const result = await userProfileQueries.upsert(user.id, validation.data)\n      return result\n    }\n  } catch (error: any) {\n    // Check if this is a Next.js redirect error - if so, re-throw it\n    if (error && typeof error === 'object' && 'digest' in error && error.digest?.startsWith('NEXT_REDIRECT')) {\n      throw error\n    }\n    console.error('Error in updateUserProfile:', error)\n    return { success: false, error: error.message || 'Failed to update profile' }\n  }\n}\n\n/**\n * Upsert user profile (create or update in one operation)\n * This is the recommended method as it handles both cases automatically\n */\nexport async function upsertUserProfile(input: UserProfileInput): Promise<UserProfileResponse> {\n  try {\n    // Validate input with Zod\n    const validation = validateWithZod(userProfileSchema, input)\n    if (!validation.success) {\n      return { success: false, error: validation.error }\n    }\n\n    // Check authentication\n    const user = await getServerSession()\n    if (!user) {\n      return { success: false, error: 'Authentication required. Please log in.' }\n    }\n\n    // Use optimized query helper\n    const result = await userProfileQueries.upsert(user.id, validation.data)\n    return result\n  } catch (error: any) {\n    // Check if this is a Next.js redirect error - if so, re-throw it\n    if (error && typeof error === 'object' && 'digest' in error && error.digest?.startsWith('NEXT_REDIRECT')) {\n      throw error\n    }\n    console.error('Error in upsertUserProfile:', error)\n    return { success: false, error: error.message || 'Failed to save profile' }\n  }\n}\n\n/**\n * Check if user profile is complete (has all required onboarding data)\n * Returns true if all required fields are filled, false otherwise\n */\nexport async function isProfileComplete(): Promise<boolean> {\n  try {\n    // Check authentication\n    const user = await getServerSession()\n    if (!user) {\n      return false\n    }\n\n    // Use optimized query helper\n    return await userProfileQueries.isComplete(user.id)\n  } catch (error: any) {\n    console.error('Error checking profile completion:', error)\n    // On error, assume incomplete to be safe\n    return false\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1233, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/liqui/OneDrive/Desktop/ai-funding-platform/.next-internal/server/app/onboarding/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {isProfileComplete as '00bb7fc876b5d429ebf45c202731d453991d49206f'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}